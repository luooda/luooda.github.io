<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.23" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.153" /><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();</script><link rel="icon" type="image/png" href="https://theme-plume.vuejs.press/favicon-32x32.png"><title>java_collections | luooda's blog</title><meta name="description" content="分享技术，记录生活"><link rel="preload" href="/assets/style-l8kqxZ9S.css" as="style"><link rel="stylesheet" href="/assets/style-l8kqxZ9S.css"><link rel="modulepreload" href="/assets/app-DF0nvRj4.js"><link rel="modulepreload" href="/assets/index.html-DRGLEwEb.js"></head><body><div id="app"><!--[--><!--[--><div class="theme-plume vp-layout" vp-container data-v-d90a7a26><!--[--><!--[--><!--]--><!--[--><span tabindex="-1" data-v-d5a8d0bc></span><a href="#VPContent" class="vp-skip-link visually-hidden" data-v-d5a8d0bc> Skip to content </a><!--]--><!----><header class="vp-nav" data-v-d90a7a26 data-v-e98a6132><div class="vp-navbar" vp-navbar data-v-e98a6132 data-v-2c31ea5e><div class="wrapper" data-v-2c31ea5e><div class="container" data-v-2c31ea5e><div class="title" data-v-2c31ea5e><div class="vp-navbar-title" data-v-2c31ea5e data-v-1a4f50af><a class="vp-link no-icon link title" href="/" data-v-1a4f50af data-v-52a753cb><!--[--><!--[--><!--]--><!--[--><!--[--><!--[--><img class="vp-image dark logo" style="" src="https://theme-plume.vuejs.press/plume.png" alt data-v-480e858a><!--]--><!--[--><img class="vp-image light logo" style="" src="https://theme-plume.vuejs.press/plume.png" alt data-v-480e858a><!--]--><!--]--><!--]--><span data-v-1a4f50af>luooda&#39;s blog</span><!--[--><!--]--><!--]--><!----></a></div></div><div class="content" data-v-2c31ea5e><div class="content-body" data-v-2c31ea5e><!--[--><!--]--><div class="vp-navbar-search search" data-v-2c31ea5e><div class="search-wrapper" data-v-97535d1e><!----><div id="local-search" data-v-97535d1e><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-97535d1e><span class="mini-search-button-container"><span class="mini-search-search-icon vpi-mini-search" aria-label="search icon"></span><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><!--[--><!--]--><nav aria-labelledby="main-nav-aria-label" class="vp-navbar-menu menu" data-v-2c31ea5e data-v-d43c1732><span id="main-nav-aria-label" class="visually-hidden" data-v-d43c1732>Main Navigation</span><!--[--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-52a753cb><!--[--><!----><span data-v-d4acf911>首页</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-52a753cb><!--[--><!----><span data-v-d4acf911>博客</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/tags/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-52a753cb><!--[--><!----><span data-v-d4acf911>标签</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/archives/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-52a753cb><!--[--><!----><span data-v-d4acf911>归档</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/project/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-52a753cb><!--[--><!----><span data-v-d4acf911>项目</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/life/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-52a753cb><!--[--><!----><span data-v-d4acf911>生活</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/read/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-52a753cb><!--[--><!----><span data-v-d4acf911>阅读</span><!----><!--]--><!----></a><!--]--><!--[--><div class="vp-flyout vp-navbar-menu-group" data-v-d43c1732 data-v-86530b6c><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-86530b6c><span class="text" data-v-86530b6c><!----><!----><span data-v-86530b6c>笔记</span><!----><span class="vpi-chevron-down text-icon" data-v-86530b6c></span></span></button><div class="menu" data-v-86530b6c><div class="vp-menu" data-v-86530b6c data-v-709dc2b1><div class="items" data-v-709dc2b1><!--[--><!--[--><div class="vp-menu-link" data-v-709dc2b1 data-v-1ff1855f><a class="vp-link no-icon link" href="/demo/" data-v-1ff1855f data-v-52a753cb><!--[--><!----> 示例 <!----><!--]--><!----></a></div><!--]--><!--[--><div class="vp-menu-link" data-v-709dc2b1 data-v-1ff1855f><a class="vp-link no-icon link" href="/notes/design_pattern/" data-v-1ff1855f data-v-52a753cb><!--[--><!----> 设计模式 <!----><!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/about/" tabindex="0" data-v-d43c1732 data-v-d4acf911 data-v-52a753cb><!--[--><!----><span data-v-d4acf911>关于我</span><!----><!--]--><!----></a><!--]--><!--]--></nav><!--[--><!--]--><!----><div class="vp-navbar-appearance appearance" data-v-2c31ea5e data-v-a295abf6><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-a295abf6 data-v-596c25a9 data-v-7eb32327><span class="check" data-v-7eb32327><span class="icon" data-v-7eb32327><!--[--><span class="vpi-sun sun" data-v-596c25a9></span><span class="vpi-moon moon" data-v-596c25a9></span><!--]--></span></span></button></div><div class="vp-social-links vp-navbar-social-links social-links" data-v-2c31ea5e data-v-ad52545c data-v-40bac536><!--[--><a class="vp-social-link no-icon" href="https://github.com/luooda" aria-label="github" target="_blank" rel="noopener" data-v-40bac536 data-v-67b21932><span class="vpi-social-github" /></a><!--]--></div><div class="vp-flyout vp-navbar-extra extra" data-v-2c31ea5e data-v-652282fd data-v-86530b6c><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-86530b6c><span class="vpi-more-horizontal icon" data-v-86530b6c></span></button><div class="menu" data-v-86530b6c><div class="vp-menu" data-v-86530b6c data-v-709dc2b1><!----><!--[--><!--[--><!----><div class="group" data-v-652282fd><div class="item appearance" data-v-652282fd><p class="label" data-v-652282fd>外观</p><div class="appearance-action" data-v-652282fd><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-652282fd data-v-596c25a9 data-v-7eb32327><span class="check" data-v-7eb32327><span class="icon" data-v-7eb32327><!--[--><span class="vpi-sun sun" data-v-596c25a9></span><span class="vpi-moon moon" data-v-596c25a9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-652282fd><div class="item social-links" data-v-652282fd><div class="vp-social-links social-links-list" data-v-652282fd data-v-40bac536><!--[--><a class="vp-social-link no-icon" href="https://github.com/luooda" aria-label="github" target="_blank" rel="noopener" data-v-40bac536 data-v-67b21932><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="vp-navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-2c31ea5e data-v-2b50024d><span class="container" data-v-2b50024d><span class="top" data-v-2b50024d></span><span class="middle" data-v-2b50024d></span><span class="bottom" data-v-2b50024d></span></span></button></div></div></div></div><div class="divider" data-v-2c31ea5e><div class="divider-line" data-v-2c31ea5e></div></div></div><!----></header><div class="vp-local-nav fixed reached-top is-blog" data-v-d90a7a26 data-v-3944d8e8><button class="hidden menu" disabled aria-expanded="false" aria-controls="SidebarNav" data-v-3944d8e8><span class="vpi-align-left menu-icon" data-v-3944d8e8></span><span class="menu-text" data-v-3944d8e8>Menu</span></button><div class="vp-local-nav-outline-dropdown" style="--vp-vh:0px;" data-v-3944d8e8 data-v-4114a62c><button data-v-4114a62c>返回顶部</button><!----></div></div><!----><!--[--><div id="VPContent" vp-content class="vp-content" data-v-d90a7a26 data-v-b2beaca7><div class="vp-doc-container is-blog" data-v-b2beaca7 data-v-23f6ad98><!--[--><!--]--><div class="container" data-v-23f6ad98><!----><div class="content" data-v-23f6ad98><div class="content-container" data-v-23f6ad98><!--[--><!--]--><main class="main" data-v-23f6ad98><nav class="vp-breadcrumb" data-v-23f6ad98 data-v-1ae4ad7a><ol vocab="https://schema.org/" typeof="BreadcrumbList" data-v-1ae4ad7a><!--[--><li property="itemListElement" typeof="ListItem" data-v-1ae4ad7a><a class="vp-link no-icon link breadcrumb" href="/" property="item" typeof="WebPage" data-v-1ae4ad7a data-v-52a753cb><!--[-->首页<!--]--><!----></a><span class="vpi-chevron-right" data-v-1ae4ad7a></span><meta property="name" content="首页" data-v-1ae4ad7a><meta property="position" content="1" data-v-1ae4ad7a></li><li property="itemListElement" typeof="ListItem" data-v-1ae4ad7a><a class="vp-link no-icon link breadcrumb" href="/blog/" property="item" typeof="WebPage" data-v-1ae4ad7a data-v-52a753cb><!--[-->博客<!--]--><!----></a><span class="vpi-chevron-right" data-v-1ae4ad7a></span><meta property="name" content="博客" data-v-1ae4ad7a><meta property="position" content="2" data-v-1ae4ad7a></li><li property="itemListElement" typeof="ListItem" data-v-1ae4ad7a><a class="vp-link no-icon link breadcrumb" href="/blog/categories/?id=0eef45" property="item" typeof="WebPage" data-v-1ae4ad7a data-v-52a753cb><!--[-->backend-blog<!--]--><!----></a><span class="vpi-chevron-right" data-v-1ae4ad7a></span><meta property="name" content="backend-blog" data-v-1ae4ad7a><meta property="position" content="3" data-v-1ae4ad7a></li><li property="itemListElement" typeof="ListItem" data-v-1ae4ad7a><a class="vp-link no-icon link breadcrumb current" href="/article/o08v0duh/" property="item" typeof="WebPage" data-v-1ae4ad7a data-v-52a753cb><!--[-->java_collections<!--]--><!----></a><!----><meta property="name" content="java_collections" data-v-1ae4ad7a><meta property="position" content="4" data-v-1ae4ad7a></li><!--]--></ol></nav><!--[--><!--]--><!--[--><h1 class="vp-doc-title page-title" data-v-27be53cb>java_collections <!----></h1><div class="vp-doc-meta" data-v-27be53cb><!--[--><!--]--><p class="reading-time" data-v-27be53cb><span class="vpi-books icon" data-v-27be53cb></span><span data-v-27be53cb>约 1628 字</span><span data-v-27be53cb>大约 5 分钟</span></p><p data-v-27be53cb><span class="vpi-tag icon" data-v-27be53cb></span><!--[--><a class="vp-link no-icon link tag vp-tag-ly47" href="/blog/tags/?tag=java" data-v-27be53cb data-v-52a753cb><!--[-->java<!--]--><!----></a><a class="vp-link no-icon link tag vp-tag-hozh" href="/blog/tags/?tag=集合类" data-v-27be53cb data-v-52a753cb><!--[-->集合类<!--]--><!----></a><a class="vp-link no-icon link tag vp-tag-6it0" href="/blog/tags/?tag=数据结构" data-v-27be53cb data-v-52a753cb><!--[-->数据结构<!--]--><!----></a><!--]--></p><!--[--><!--]--><p class="create-time" data-v-27be53cb><span class="vpi-clock icon" data-v-27be53cb></span><span data-v-27be53cb>2025-08-06</span></p></div><!--]--><!--[--><!--]--><div class="_article_o08v0duh_ external-link-icon-enabled vp-doc plume-content" vp-content data-v-23f6ad98><!--[--><!--]--><div data-v-23f6ad98><h3 id="算法题常用数据结构核心操作汇总-java" tabindex="-1"><a class="header-anchor" href="#算法题常用数据结构核心操作汇总-java"><span><strong>算法题常用数据结构核心操作汇总 (Java)</strong></span></a></h3><p>掌握正确的数据结构是高效解决算法问题的关键。不同的数据结构在增、删、改、查等操作上具有不同的时间复杂度，选择合适的结构能让您的代码事半功倍。</p><hr><h3 id="_1-动态数组-dynamic-array" tabindex="-1"><a class="header-anchor" href="#_1-动态数组-dynamic-array"><span><strong>1. 动态数组 (Dynamic Array)</strong></span></a></h3><ul><li><strong>特点</strong>: 逻辑上和物理上都连续的存储空间，支持快速随机访问。</li><li><strong>Java 实现</strong>: <code>java.util.ArrayList</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>ArrayList&lt;E&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Add)</strong></td><td style="text-align:left;"><code>add(E element)</code></td><td style="text-align:left;"><strong>O(1)</strong> (均摊)</td><td style="text-align:left;">在末尾添加。当容量不足时扩容，导致单次操作可能为 O(n)。</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>add(int index, E element)</code></td><td style="text-align:left;">O(n)</td><td style="text-align:left;">在中间插入，需要移动后续所有元素。</td></tr><tr><td style="text-align:left;"><strong>删 (Remove)</strong></td><td style="text-align:left;"><code>remove(int index)</code></td><td style="text-align:left;">O(n)</td><td style="text-align:left;">从中间删除，需要移动后续所有元素。</td></tr><tr><td style="text-align:left;"><strong>改 (Update)</strong></td><td style="text-align:left;"><code>set(int index, E element)</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;"><strong>核心优势</strong>：通过索引直接定位，速度极快。</td></tr><tr><td style="text-align:left;"><strong>查 (Get)</strong></td><td style="text-align:left;"><code>get(int index)</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;"><strong>核心优势</strong>：同上。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>size()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">获取大小。</td></tr></tbody></table><hr><h3 id="_2-链表-linked-list" tabindex="-1"><a class="header-anchor" href="#_2-链表-linked-list"><span><strong>2. 链表 (Linked List)</strong></span></a></h3><ul><li><strong>特点</strong>: 物理上不连续，通过节点和指针连接。在<strong>首尾</strong>操作非常快。</li><li><strong>Java 实现</strong>: <code>java.util.LinkedList</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>LinkedList&lt;E&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Add)</strong></td><td style="text-align:left;"><code>addFirst(E e)</code>, <code>addLast(E e)</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;"><strong>核心优势</strong>：在两端添加。</td></tr><tr><td style="text-align:left;"><strong>删 (Remove)</strong></td><td style="text-align:left;"><code>removeFirst()</code>, <code>removeLast()</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;"><strong>核心优势</strong>：在两端删除。</td></tr><tr><td style="text-align:left;"><strong>改 (Update)</strong></td><td style="text-align:left;"><code>set(int index, E element)</code></td><td style="text-align:left;">O(n)</td><td style="text-align:left;">速度慢，需要先遍历找到该索引。</td></tr><tr><td style="text-align:left;"><strong>查 (Get)</strong></td><td style="text-align:left;"><code>getFirst()</code>, <code>getLast()</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;">获取两端元素。</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>get(int index)</code></td><td style="text-align:left;">O(n)</td><td style="text-align:left;">速度慢，需要遍历。</td></tr></tbody></table><blockquote><p><strong>注意</strong>: <code>LinkedList</code> 实现了 <code>Deque</code> 接口，因此它常常被用作栈或队列。</p></blockquote><hr><h3 id="_3-栈-stack-lifo" tabindex="-1"><a class="header-anchor" href="#_3-栈-stack-lifo"><span><strong>3. 栈 (Stack - LIFO)</strong></span></a></h3><ul><li><strong>特点</strong>: 后进先出 (Last-In, First-Out)。</li><li><strong>Java 实现</strong>: <strong>推荐使用 <code>java.util.ArrayDeque</code></strong></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>ArrayDeque&lt;E&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Push)</strong></td><td style="text-align:left;"><code>push(E e)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">元素入栈顶。</td></tr><tr><td style="text-align:left;"><strong>删 (Pop)</strong></td><td style="text-align:left;"><code>pop()</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">元素出栈顶。</td></tr><tr><td style="text-align:left;"><strong>查 (Peek)</strong></td><td style="text-align:left;"><code>peek()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">查看栈顶元素，不删除。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>isEmpty()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">判断是否为空。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">DFS、括号匹配、表达式求值、单调栈。</td></tr></tbody></table><hr><h3 id="_4-队列-queue-fifo" tabindex="-1"><a class="header-anchor" href="#_4-队列-queue-fifo"><span><strong>4. 队列 (Queue - FIFO)</strong></span></a></h3><ul><li><strong>特点</strong>: 先进先出 (First-In, First-Out)。</li><li><strong>Java 实现</strong>: <strong>推荐使用 <code>java.util.LinkedList</code> 或 <code>java.util.ArrayDeque</code></strong></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>Queue&lt;E&gt;</code> 接口方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Enqueue)</strong></td><td style="text-align:left;"><code>offer(E e)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">元素入队尾。</td></tr><tr><td style="text-align:left;"><strong>删 (Dequeue)</strong></td><td style="text-align:left;"><code>poll()</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">元素出队头。</td></tr><tr><td style="text-align:left;"><strong>查 (Peek)</strong></td><td style="text-align:left;"><code>peek()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">查看队头元素，不删除。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>isEmpty()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">判断是否为空。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">BFS、层序遍历。</td></tr></tbody></table><hr><h3 id="_5-优先队列-priority-queue-heap" tabindex="-1"><a class="header-anchor" href="#_5-优先队列-priority-queue-heap"><span><strong>5. 优先队列 (Priority Queue / Heap)</strong></span></a></h3><ul><li><strong>特点</strong>: 每次出队的都是优先级最高的元素。底层由<strong>堆</strong>实现。</li><li><strong>Java 实现</strong>: <code>java.util.PriorityQueue</code> (默认是<strong>最小堆</strong>)</li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>PriorityQueue&lt;E&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Add)</strong></td><td style="text-align:left;"><code>offer(E e)</code></td><td style="text-align:left;"><strong>O(log n)</strong></td><td style="text-align:left;">添加元素并维护堆结构。</td></tr><tr><td style="text-align:left;"><strong>删 (Poll)</strong></td><td style="text-align:left;"><code>poll()</code></td><td style="text-align:left;"><strong>O(log n)</strong></td><td style="text-align:left;">移除并返回堆顶元素（最小元）。</td></tr><tr><td style="text-align:left;"><strong>查 (Peek)</strong></td><td style="text-align:left;"><code>peek()</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;">查看堆顶元素。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>isEmpty()</code>, <code>size()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">Dijkstra/Prim 算法、Top K 问题、合并 K 个有序链表。</td></tr></tbody></table><blockquote><p><strong>Tip</strong>: 创建最大堆: <code>new PriorityQueue&lt;&gt;(Comparator.reverseOrder());</code> 或 <code>new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</code></p></blockquote><hr><h3 id="_6-哈希集合-hashset" tabindex="-1"><a class="header-anchor" href="#_6-哈希集合-hashset"><span><strong>6. 哈希集合 (HashSet)</strong></span></a></h3><ul><li><strong>特点</strong>: 存储不重复的元素，无序。</li><li><strong>Java 实现</strong>: <code>java.util.HashSet</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>HashSet&lt;E&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Add)</strong></td><td style="text-align:left;"><code>add(E e)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">如果元素已存在则添加失败。</td></tr><tr><td style="text-align:left;"><strong>删 (Remove)</strong></td><td style="text-align:left;"><code>remove(Object o)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">删除指定元素。</td></tr><tr><td style="text-align:left;"><strong>查 (Query)</strong></td><td style="text-align:left;"><code>contains(Object o)</code></td><td style="text-align:left;"><strong>O(1)</strong> (均摊)</td><td style="text-align:left;"><strong>核心优势</strong>：极快地判断元素是否存在。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>size()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">获取元素数量。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">去重、快速查找元素是否存在。</td></tr></tbody></table><hr><h3 id="_7-哈希映射-hashmap" tabindex="-1"><a class="header-anchor" href="#_7-哈希映射-hashmap"><span><strong>7. 哈希映射 (HashMap)</strong></span></a></h3><ul><li><strong>特点</strong>: 存储键值对 (<code>&lt;Key, Value&gt;</code>)，无序。</li><li><strong>Java 实现</strong>: <code>java.util.HashMap</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>HashMap&lt;K, V&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增/改</strong></td><td style="text-align:left;"><code>put(K key, V value)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">添加或更新键值对。</td></tr><tr><td style="text-align:left;"><strong>删 (Remove)</strong></td><td style="text-align:left;"><code>remove(Object key)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">根据键删除。</td></tr><tr><td style="text-align:left;"><strong>查 (Get)</strong></td><td style="text-align:left;"><code>get(Object key)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">根据键查找值。</td></tr><tr><td style="text-align:left;"><strong>查 (Query)</strong></td><td style="text-align:left;"><code>containsKey(Object key)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;"><strong>核心优势</strong>：极快地判断键是否存在。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>keySet()</code>, <code>values()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">获取键集或值集合。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">频次统计、缓存、建立映射关系。</td></tr></tbody></table><hr><h3 id="_8-有序树集合-映射-treeset-treemap" tabindex="-1"><a class="header-anchor" href="#_8-有序树集合-映射-treeset-treemap"><span><strong>8. 有序树集合/映射 (TreeSet/TreeMap)</strong></span></a></h3><ul><li><strong>特点</strong>: 基于<strong>平衡二叉搜索树（红黑树）</strong>，元素始终保持有序。</li><li><strong>Java 实现</strong>: <code>java.util.TreeSet</code>, <code>java.util.TreeMap</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>TreeMap&lt;K, V&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增/改</strong></td><td style="text-align:left;"><code>put(K key, V value)</code></td><td style="text-align:left;"><strong>O(log n)</strong></td><td style="text-align:left;">添加/修改，并保持有序。</td></tr><tr><td style="text-align:left;"><strong>删</strong></td><td style="text-align:left;"><code>remove(Object key)</code></td><td style="text-align:left;"><strong>O(log n)</strong></td><td style="text-align:left;">删除，并保持有序。</td></tr><tr><td style="text-align:left;"><strong>查</strong></td><td style="text-align:left;"><code>get(Object key)</code></td><td style="text-align:left;"><strong>O(log n)</strong></td><td style="text-align:left;">查找。</td></tr><tr><td style="text-align:left;"><strong>特殊查询</strong></td><td style="text-align:left;"><code>firstKey()</code>, <code>lastKey()</code></td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">查找最小/最大键。</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>floorKey()</code>, <code>ceilingKey()</code></td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">查找小于等于/大于等于某值的键。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">需要有序数据、查找最近邻元素、区间问题。</td></tr></tbody></table><hr><h3 id="_9-图-graph" tabindex="-1"><a class="header-anchor" href="#_9-图-graph"><span><strong>9. 图 (Graph)</strong></span></a></h3><ul><li><strong>特点</strong>: 由顶点和边构成，是一种<strong>抽象模型</strong>，需手动实现。</li><li><strong>Java 实现</strong>: 常用<strong>邻接表</strong> <code>List&lt;List&lt;Integer&gt;&gt;</code> 或 <code>List&lt;List&lt;Edge&gt;&gt;</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">邻接表方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Add Edge)</strong></td><td style="text-align:left;"><code>graph.get(u).add(v);</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">添加一条从 u 到 v 的边。</td></tr><tr><td style="text-align:left;"><strong>删 (Remove Edge)</strong></td><td style="text-align:left;"><code>graph.get(u).remove(v);</code></td><td style="text-align:left;">O(degree(u))</td><td style="text-align:left;">需要遍历 u 的邻居列表。</td></tr><tr><td style="text-align:left;"><strong>查 (Iterate)</strong></td><td style="text-align:left;"><code>for (int neighbor : graph.get(u))</code></td><td style="text-align:left;">O(degree(u))</td><td style="text-align:left;">遍历 u 的所有邻居。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">所有图论问题：DFS, BFS, 最短路径, 拓扑排序等。</td></tr></tbody></table><hr><h3 id="_10-并查集-union-find" tabindex="-1"><a class="header-anchor" href="#_10-并查集-union-find"><span><strong>10. 并查集 (Union-Find)</strong></span></a></h3><ul><li><strong>特点</strong>: 高效地管理不相交集合的合并与查询。需<strong>手动实现</strong>。</li><li><strong>Java 实现</strong>: 通常使用一个 <code>parent</code> 数组。</li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">常用方法名</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>合并</strong></td><td style="text-align:left;"><code>union(int i, int j)</code></td><td style="text-align:left;"><strong>~O(1)</strong> (均摊)</td><td style="text-align:left;">合并 i 和 j 所在的集合。</td></tr><tr><td style="text-align:left;"><strong>查找</strong></td><td style="text-align:left;"><code>find(int i)</code></td><td style="text-align:left;"><strong>~O(1)</strong> (均摊)</td><td style="text-align:left;">查找 i 所在集合的根。</td></tr><tr><td style="text-align:left;"><strong>查询</strong></td><td style="text-align:left;"><code>isConnected(int i, int j)</code></td><td style="text-align:left;"><strong>~O(1)</strong> (均摊)</td><td style="text-align:left;">判断 i 和 j 是否在同一集合。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">判断图的连通性、Kruskal 算法求最小生成树、检测环。</td></tr></tbody></table><hr><h3 id="_11-字典树-trie-prefix-tree" tabindex="-1"><a class="header-anchor" href="#_11-字典树-trie-prefix-tree"><span><strong>11. 字典树 (Trie / Prefix Tree)</strong></span></a></h3><ul><li><strong>特点</strong>: 高效地存储和检索字符串集合，尤其擅长前缀相关的操作。需<strong>手动实现</strong>。</li><li><strong>Java 实现</strong>: 使用嵌套的 <code>Node</code> 类。</li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">常用方法名</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Insert)</strong></td><td style="text-align:left;"><code>insert(String word)</code></td><td style="text-align:left;">O(L)</td><td style="text-align:left;">插入一个单词，L 为单词长度。</td></tr><tr><td style="text-align:left;"><strong>查 (Search)</strong></td><td style="text-align:left;"><code>search(String word)</code></td><td style="text-align:left;">O(L)</td><td style="text-align:left;">查找一个完整的单词是否存在。</td></tr><tr><td style="text-align:left;"><strong>查 (Prefix)</strong></td><td style="text-align:left;"><code>startsWith(String prefix)</code></td><td style="text-align:left;">O(L)</td><td style="text-align:left;">查找是否存在以某前缀开头的单词。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">搜索引擎自动补全、拼写检查、IP 路由。</td></tr></tbody></table></div><!----><!----><!----></div></main><footer class="vp-doc-footer" data-v-23f6ad98 data-v-fda6bbae><!--[--><!--]--><!----><div class="contributors" aria-label="Contributors" data-v-fda6bbae><span class="contributors-label" data-v-fda6bbae>贡献者: </span><span class="contributors-info" data-v-fda6bbae><!--[--><!--[--><span class="contributor" data-v-fda6bbae>luooda</span><!----><!--]--><!--]--></span></div><nav class="prev-next" data-v-fda6bbae><div class="pager" data-v-fda6bbae><!----></div><div class="pager" data-v-fda6bbae><a class="vp-link no-icon link pager-link next" href="/article/qwkwc3s3/" data-v-fda6bbae data-v-52a753cb><!--[--><span class="desc" data-v-fda6bbae>下一页</span><span class="title" data-v-fda6bbae>web3</span><!--]--><!----></a></div></nav></footer><div id="comment" class="giscus-wrapper input-top vp-comment" vp-comment style="display:block;" data-v-23f6ad98><div style="display: flex;align-items: center;justify-content: center;height: 96px"><span style="--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; preserveAspectRatio=&#39;xMidYMid&#39; viewBox=&#39;25 25 50 50&#39;%3E%3CanimateTransform attributeName=&#39;transform&#39; type=&#39;rotate&#39; dur=&#39;2s&#39; keyTimes=&#39;0;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;360&#39;%3E%3C/animateTransform%3E%3Ccircle cx=&#39;50&#39; cy=&#39;50&#39; r=&#39;20&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39; stroke-width=&#39;4&#39; stroke-linecap=&#39;round&#39;%3E%3Canimate attributeName=&#39;stroke-dasharray&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;1,200;90,200;1,200&#39;%3E%3C/animate%3E%3Canimate attributeName=&#39;stroke-dashoffset&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;-35px;-125px&#39;%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)"></span></div></div><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!--]--><button style="display:none;" type="button" class="vp-back-to-top" aria-label="back to top" data-v-d90a7a26 data-v-bcf8d9a6><span class="percent" data-allow-mismatch data-v-bcf8d9a6>0%</span><span class="show icon vpi-back-to-top" data-v-bcf8d9a6></span><svg aria-hidden="true" data-v-bcf8d9a6><circle cx="50%" cy="50%" data-allow-mismatch style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-bcf8d9a6></circle></svg></button><footer class="vp-footer" vp-footer data-v-d90a7a26 data-v-400675cf><!--[--><div class="container" data-v-400675cf><p class="message" data-v-400675cf>Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a></p><!----></div><!--]--></footer><!--[--><!--]--><!--]--></div><!----><!--]--><!--[--><!--]--><!--]--></div><script type="module" src="/assets/app-DF0nvRj4.js" defer></script></body></html>