import{_ as e,c as l,a as d,o as n}from"./app-DF0nvRj4.js";const s={};function a(g,t){return n(),l("div",null,t[0]||(t[0]=[d('<h3 id="算法题常用数据结构核心操作汇总-java" tabindex="-1"><a class="header-anchor" href="#算法题常用数据结构核心操作汇总-java"><span><strong>算法题常用数据结构核心操作汇总 (Java)</strong></span></a></h3><p>掌握正确的数据结构是高效解决算法问题的关键。不同的数据结构在增、删、改、查等操作上具有不同的时间复杂度，选择合适的结构能让您的代码事半功倍。</p><hr><h3 id="_1-动态数组-dynamic-array" tabindex="-1"><a class="header-anchor" href="#_1-动态数组-dynamic-array"><span><strong>1. 动态数组 (Dynamic Array)</strong></span></a></h3><ul><li><strong>特点</strong>: 逻辑上和物理上都连续的存储空间，支持快速随机访问。</li><li><strong>Java 实现</strong>: <code>java.util.ArrayList</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>ArrayList&lt;E&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Add)</strong></td><td style="text-align:left;"><code>add(E element)</code></td><td style="text-align:left;"><strong>O(1)</strong> (均摊)</td><td style="text-align:left;">在末尾添加。当容量不足时扩容，导致单次操作可能为 O(n)。</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>add(int index, E element)</code></td><td style="text-align:left;">O(n)</td><td style="text-align:left;">在中间插入，需要移动后续所有元素。</td></tr><tr><td style="text-align:left;"><strong>删 (Remove)</strong></td><td style="text-align:left;"><code>remove(int index)</code></td><td style="text-align:left;">O(n)</td><td style="text-align:left;">从中间删除，需要移动后续所有元素。</td></tr><tr><td style="text-align:left;"><strong>改 (Update)</strong></td><td style="text-align:left;"><code>set(int index, E element)</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;"><strong>核心优势</strong>：通过索引直接定位，速度极快。</td></tr><tr><td style="text-align:left;"><strong>查 (Get)</strong></td><td style="text-align:left;"><code>get(int index)</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;"><strong>核心优势</strong>：同上。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>size()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">获取大小。</td></tr></tbody></table><hr><h3 id="_2-链表-linked-list" tabindex="-1"><a class="header-anchor" href="#_2-链表-linked-list"><span><strong>2. 链表 (Linked List)</strong></span></a></h3><ul><li><strong>特点</strong>: 物理上不连续，通过节点和指针连接。在<strong>首尾</strong>操作非常快。</li><li><strong>Java 实现</strong>: <code>java.util.LinkedList</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>LinkedList&lt;E&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Add)</strong></td><td style="text-align:left;"><code>addFirst(E e)</code>, <code>addLast(E e)</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;"><strong>核心优势</strong>：在两端添加。</td></tr><tr><td style="text-align:left;"><strong>删 (Remove)</strong></td><td style="text-align:left;"><code>removeFirst()</code>, <code>removeLast()</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;"><strong>核心优势</strong>：在两端删除。</td></tr><tr><td style="text-align:left;"><strong>改 (Update)</strong></td><td style="text-align:left;"><code>set(int index, E element)</code></td><td style="text-align:left;">O(n)</td><td style="text-align:left;">速度慢，需要先遍历找到该索引。</td></tr><tr><td style="text-align:left;"><strong>查 (Get)</strong></td><td style="text-align:left;"><code>getFirst()</code>, <code>getLast()</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;">获取两端元素。</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>get(int index)</code></td><td style="text-align:left;">O(n)</td><td style="text-align:left;">速度慢，需要遍历。</td></tr></tbody></table><blockquote><p><strong>注意</strong>: <code>LinkedList</code> 实现了 <code>Deque</code> 接口，因此它常常被用作栈或队列。</p></blockquote><hr><h3 id="_3-栈-stack-lifo" tabindex="-1"><a class="header-anchor" href="#_3-栈-stack-lifo"><span><strong>3. 栈 (Stack - LIFO)</strong></span></a></h3><ul><li><strong>特点</strong>: 后进先出 (Last-In, First-Out)。</li><li><strong>Java 实现</strong>: <strong>推荐使用 <code>java.util.ArrayDeque</code></strong></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>ArrayDeque&lt;E&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Push)</strong></td><td style="text-align:left;"><code>push(E e)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">元素入栈顶。</td></tr><tr><td style="text-align:left;"><strong>删 (Pop)</strong></td><td style="text-align:left;"><code>pop()</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">元素出栈顶。</td></tr><tr><td style="text-align:left;"><strong>查 (Peek)</strong></td><td style="text-align:left;"><code>peek()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">查看栈顶元素，不删除。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>isEmpty()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">判断是否为空。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">DFS、括号匹配、表达式求值、单调栈。</td></tr></tbody></table><hr><h3 id="_4-队列-queue-fifo" tabindex="-1"><a class="header-anchor" href="#_4-队列-queue-fifo"><span><strong>4. 队列 (Queue - FIFO)</strong></span></a></h3><ul><li><strong>特点</strong>: 先进先出 (First-In, First-Out)。</li><li><strong>Java 实现</strong>: <strong>推荐使用 <code>java.util.LinkedList</code> 或 <code>java.util.ArrayDeque</code></strong></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>Queue&lt;E&gt;</code> 接口方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Enqueue)</strong></td><td style="text-align:left;"><code>offer(E e)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">元素入队尾。</td></tr><tr><td style="text-align:left;"><strong>删 (Dequeue)</strong></td><td style="text-align:left;"><code>poll()</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">元素出队头。</td></tr><tr><td style="text-align:left;"><strong>查 (Peek)</strong></td><td style="text-align:left;"><code>peek()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">查看队头元素，不删除。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>isEmpty()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">判断是否为空。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">BFS、层序遍历。</td></tr></tbody></table><hr><h3 id="_5-优先队列-priority-queue-heap" tabindex="-1"><a class="header-anchor" href="#_5-优先队列-priority-queue-heap"><span><strong>5. 优先队列 (Priority Queue / Heap)</strong></span></a></h3><ul><li><strong>特点</strong>: 每次出队的都是优先级最高的元素。底层由<strong>堆</strong>实现。</li><li><strong>Java 实现</strong>: <code>java.util.PriorityQueue</code> (默认是<strong>最小堆</strong>)</li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>PriorityQueue&lt;E&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Add)</strong></td><td style="text-align:left;"><code>offer(E e)</code></td><td style="text-align:left;"><strong>O(log n)</strong></td><td style="text-align:left;">添加元素并维护堆结构。</td></tr><tr><td style="text-align:left;"><strong>删 (Poll)</strong></td><td style="text-align:left;"><code>poll()</code></td><td style="text-align:left;"><strong>O(log n)</strong></td><td style="text-align:left;">移除并返回堆顶元素（最小元）。</td></tr><tr><td style="text-align:left;"><strong>查 (Peek)</strong></td><td style="text-align:left;"><code>peek()</code></td><td style="text-align:left;"><strong>O(1)</strong></td><td style="text-align:left;">查看堆顶元素。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>isEmpty()</code>, <code>size()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">Dijkstra/Prim 算法、Top K 问题、合并 K 个有序链表。</td></tr></tbody></table><blockquote><p><strong>Tip</strong>: 创建最大堆: <code>new PriorityQueue&lt;&gt;(Comparator.reverseOrder());</code> 或 <code>new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</code></p></blockquote><hr><h3 id="_6-哈希集合-hashset" tabindex="-1"><a class="header-anchor" href="#_6-哈希集合-hashset"><span><strong>6. 哈希集合 (HashSet)</strong></span></a></h3><ul><li><strong>特点</strong>: 存储不重复的元素，无序。</li><li><strong>Java 实现</strong>: <code>java.util.HashSet</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>HashSet&lt;E&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Add)</strong></td><td style="text-align:left;"><code>add(E e)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">如果元素已存在则添加失败。</td></tr><tr><td style="text-align:left;"><strong>删 (Remove)</strong></td><td style="text-align:left;"><code>remove(Object o)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">删除指定元素。</td></tr><tr><td style="text-align:left;"><strong>查 (Query)</strong></td><td style="text-align:left;"><code>contains(Object o)</code></td><td style="text-align:left;"><strong>O(1)</strong> (均摊)</td><td style="text-align:left;"><strong>核心优势</strong>：极快地判断元素是否存在。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>size()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">获取元素数量。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">去重、快速查找元素是否存在。</td></tr></tbody></table><hr><h3 id="_7-哈希映射-hashmap" tabindex="-1"><a class="header-anchor" href="#_7-哈希映射-hashmap"><span><strong>7. 哈希映射 (HashMap)</strong></span></a></h3><ul><li><strong>特点</strong>: 存储键值对 (<code>&lt;Key, Value&gt;</code>)，无序。</li><li><strong>Java 实现</strong>: <code>java.util.HashMap</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>HashMap&lt;K, V&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增/改</strong></td><td style="text-align:left;"><code>put(K key, V value)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">添加或更新键值对。</td></tr><tr><td style="text-align:left;"><strong>删 (Remove)</strong></td><td style="text-align:left;"><code>remove(Object key)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">根据键删除。</td></tr><tr><td style="text-align:left;"><strong>查 (Get)</strong></td><td style="text-align:left;"><code>get(Object key)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;">根据键查找值。</td></tr><tr><td style="text-align:left;"><strong>查 (Query)</strong></td><td style="text-align:left;"><code>containsKey(Object key)</code></td><td style="text-align:left;">O(1) (均摊)</td><td style="text-align:left;"><strong>核心优势</strong>：极快地判断键是否存在。</td></tr><tr><td style="text-align:left;"><strong>常用</strong></td><td style="text-align:left;"><code>keySet()</code>, <code>values()</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">获取键集或值集合。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">频次统计、缓存、建立映射关系。</td></tr></tbody></table><hr><h3 id="_8-有序树集合-映射-treeset-treemap" tabindex="-1"><a class="header-anchor" href="#_8-有序树集合-映射-treeset-treemap"><span><strong>8. 有序树集合/映射 (TreeSet/TreeMap)</strong></span></a></h3><ul><li><strong>特点</strong>: 基于<strong>平衡二叉搜索树（红黑树）</strong>，元素始终保持有序。</li><li><strong>Java 实现</strong>: <code>java.util.TreeSet</code>, <code>java.util.TreeMap</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;"><code>TreeMap&lt;K, V&gt;</code> 方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增/改</strong></td><td style="text-align:left;"><code>put(K key, V value)</code></td><td style="text-align:left;"><strong>O(log n)</strong></td><td style="text-align:left;">添加/修改，并保持有序。</td></tr><tr><td style="text-align:left;"><strong>删</strong></td><td style="text-align:left;"><code>remove(Object key)</code></td><td style="text-align:left;"><strong>O(log n)</strong></td><td style="text-align:left;">删除，并保持有序。</td></tr><tr><td style="text-align:left;"><strong>查</strong></td><td style="text-align:left;"><code>get(Object key)</code></td><td style="text-align:left;"><strong>O(log n)</strong></td><td style="text-align:left;">查找。</td></tr><tr><td style="text-align:left;"><strong>特殊查询</strong></td><td style="text-align:left;"><code>firstKey()</code>, <code>lastKey()</code></td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">查找最小/最大键。</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>floorKey()</code>, <code>ceilingKey()</code></td><td style="text-align:left;">O(log n)</td><td style="text-align:left;">查找小于等于/大于等于某值的键。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">需要有序数据、查找最近邻元素、区间问题。</td></tr></tbody></table><hr><h3 id="_9-图-graph" tabindex="-1"><a class="header-anchor" href="#_9-图-graph"><span><strong>9. 图 (Graph)</strong></span></a></h3><ul><li><strong>特点</strong>: 由顶点和边构成，是一种<strong>抽象模型</strong>，需手动实现。</li><li><strong>Java 实现</strong>: 常用<strong>邻接表</strong> <code>List&lt;List&lt;Integer&gt;&gt;</code> 或 <code>List&lt;List&lt;Edge&gt;&gt;</code></li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">邻接表方法</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Add Edge)</strong></td><td style="text-align:left;"><code>graph.get(u).add(v);</code></td><td style="text-align:left;">O(1)</td><td style="text-align:left;">添加一条从 u 到 v 的边。</td></tr><tr><td style="text-align:left;"><strong>删 (Remove Edge)</strong></td><td style="text-align:left;"><code>graph.get(u).remove(v);</code></td><td style="text-align:left;">O(degree(u))</td><td style="text-align:left;">需要遍历 u 的邻居列表。</td></tr><tr><td style="text-align:left;"><strong>查 (Iterate)</strong></td><td style="text-align:left;"><code>for (int neighbor : graph.get(u))</code></td><td style="text-align:left;">O(degree(u))</td><td style="text-align:left;">遍历 u 的所有邻居。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">所有图论问题：DFS, BFS, 最短路径, 拓扑排序等。</td></tr></tbody></table><hr><h3 id="_10-并查集-union-find" tabindex="-1"><a class="header-anchor" href="#_10-并查集-union-find"><span><strong>10. 并查集 (Union-Find)</strong></span></a></h3><ul><li><strong>特点</strong>: 高效地管理不相交集合的合并与查询。需<strong>手动实现</strong>。</li><li><strong>Java 实现</strong>: 通常使用一个 <code>parent</code> 数组。</li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">常用方法名</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>合并</strong></td><td style="text-align:left;"><code>union(int i, int j)</code></td><td style="text-align:left;"><strong>~O(1)</strong> (均摊)</td><td style="text-align:left;">合并 i 和 j 所在的集合。</td></tr><tr><td style="text-align:left;"><strong>查找</strong></td><td style="text-align:left;"><code>find(int i)</code></td><td style="text-align:left;"><strong>~O(1)</strong> (均摊)</td><td style="text-align:left;">查找 i 所在集合的根。</td></tr><tr><td style="text-align:left;"><strong>查询</strong></td><td style="text-align:left;"><code>isConnected(int i, int j)</code></td><td style="text-align:left;"><strong>~O(1)</strong> (均摊)</td><td style="text-align:left;">判断 i 和 j 是否在同一集合。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">判断图的连通性、Kruskal 算法求最小生成树、检测环。</td></tr></tbody></table><hr><h3 id="_11-字典树-trie-prefix-tree" tabindex="-1"><a class="header-anchor" href="#_11-字典树-trie-prefix-tree"><span><strong>11. 字典树 (Trie / Prefix Tree)</strong></span></a></h3><ul><li><strong>特点</strong>: 高效地存储和检索字符串集合，尤其擅长前缀相关的操作。需<strong>手动实现</strong>。</li><li><strong>Java 实现</strong>: 使用嵌套的 <code>Node</code> 类。</li></ul><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">常用方法名</th><th style="text-align:left;">时间复杂度</th><th style="text-align:left;">备注 / 常用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>增 (Insert)</strong></td><td style="text-align:left;"><code>insert(String word)</code></td><td style="text-align:left;">O(L)</td><td style="text-align:left;">插入一个单词，L 为单词长度。</td></tr><tr><td style="text-align:left;"><strong>查 (Search)</strong></td><td style="text-align:left;"><code>search(String word)</code></td><td style="text-align:left;">O(L)</td><td style="text-align:left;">查找一个完整的单词是否存在。</td></tr><tr><td style="text-align:left;"><strong>查 (Prefix)</strong></td><td style="text-align:left;"><code>startsWith(String prefix)</code></td><td style="text-align:left;">O(L)</td><td style="text-align:left;">查找是否存在以某前缀开头的单词。</td></tr><tr><td style="text-align:left;"><strong>场景</strong></td><td style="text-align:left;">-</td><td style="text-align:left;">-</td><td style="text-align:left;">搜索引擎自动补全、拼写检查、IP 路由。</td></tr></tbody></table>',48)]))}const o=e(s,[["render",a]]),i=JSON.parse('{"path":"/article/o08v0duh/","title":"java_collections","lang":"zh-CN","frontmatter":{"title":"java_collections","createTime":"2025/08/06 16:37:27","permalink":"/article/o08v0duh/","tags":["java","集合类","数据结构"]},"readingTime":{"minutes":5.43,"words":1628},"git":{"createdTime":1754519043000,"updatedTime":1754519043000,"contributors":[{"name":"luooda","username":"luooda","email":"phnoneld@outlook.com","commits":1,"avatar":"https://avatars.githubusercontent.com/luooda?v=4","url":"https://github.com/luooda"}]},"filePathRelative":"backend-blog/java_collections.md","headers":[],"categoryList":[{"id":"0eef45","sort":10011,"name":"backend-blog"}]}');export{o as comp,i as data};
